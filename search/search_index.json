{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Token Risk Classification","text":"<p>Token Risk Classification(TRC) aims at identifying and cataloging scams like honeypots, and intentional backdoors that may be present in token smart contracts within the crypto ecosystem. This classification serves as:</p> <ul> <li> <p>A Shield against Malicious Contracts: By showcasing a defined list of malicious token contract patterns, it empowers users and project teams to recognize and steer clear of contracts with hidden intents, thereby ensuring safer interactions within the decentralized space.</p> </li> <li> <p>A Testing Ground for Developers: With a clear classification of malicious patterns and real-world examples, developers creating tools to detect these malicious token smart contracts can effectively evaluate their systems against a standardized classification.</p> </li> <li> <p>A Catalyst for Research: By elucidating the deceitful practices adopted in token smart contracts, we aspire to drive more research towards crypto user safety, encouraging the community to devise strategies that deter such behaviors.</p> </li> <li> <p>An Educational Asset: This repository stands as an initiative to amplify awareness, serving as an informational reservoir, shedding light on potential contract pitfalls and deceitful patterns to the advantage of the community.</p> </li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Descriptions: Each pattern is thoroughly dissected, detailing its operation, potential consequences, and techniques for avoidance.</li> <li>Real-world Samples: For each pattern, contract samples that exemplify the described malicious intent are provided, forming a practical point of reference.</li> </ul>"},{"location":"#contribute","title":"Contribute","text":"<p>Maintaining the relevance and comprehensiveness of this repository is a joint endeavor. We earnestly welcome community contributions. For details on how to contribute, kindly refer to our Contribution Guidelines.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>Our profound gratitude to all developers, researchers, and crypto enthusiasts who have been instrumental in shaping this repository. We hope to collaboratively fortify crypto user security and invite everyone to join this collective endeavor.</p>"},{"location":"TRC-001/","title":"TRC-001 Honeypot","text":""},{"location":"TRC-001/#description","title":"Description","text":"<p>A Honeypot token refers to a malicious token smart contract designed to attract users to buy the token but prevent them from selling it. This is achieved through malicious code within the contract, which traps the user's assets, leading to potential financial loss.</p>"},{"location":"TRC-001/#risk-samples","title":"Risk Samples","text":"<ul> <li>01.sol </li> <li>02.sol </li> <li>03.sol </li> <li>04.sol </li> <li>05.sol</li> </ul>"},{"location":"TRC-002/","title":"TRC-002 Mintable","text":""},{"location":"TRC-002/#description","title":"Description","text":"<p>Mintable indicates that the token allows for potential malicious minting. The deployer can continuously mint new tokens, draining the liquidity pool for profit. This can trigger a massive sell-off, causing the coin price to plummet and leading to significant losses for other token holders.</p>"},{"location":"TRC-002/#risk-pattern","title":"Risk Pattern","text":"<pre><code>function mint(unit256 amount) external onlyowner {\n  _balances[_msgSender()] += amount;\n}\n</code></pre>"},{"location":"TRC-002/#risk-samples","title":"Risk Samples","text":"<ul> <li>01.sol </li> <li>02.sol </li> <li>03.sol </li> <li>04.sol</li> </ul>"},{"location":"TRC-003/","title":"TRC-003 OwnershipRetrieval","text":""},{"location":"TRC-003/#description","title":"Description","text":"<p>Ownership allows adjustments to contract parameters and status, such as minting, slippage modification, trading suspension, and blacklist settings. If the contract's owner cannot be retrieved, is a black hole address, or lacks an owner, these functions are usually disabled. However, these risky functions may be reactivated if ownership is reclaimed.</p>"},{"location":"TRC-003/#risk-pattern","title":"Risk Pattern","text":"<pre><code>function lock(uint256 time) public virtual onlyOwner {\n  _previousOwner = _owner;\n  _owner = address(0);\n}\n\nfunction unlock() public virtual {\n  require(_previousOwner == msg.sender, );\n  _owner = _previousOwner;\n}\n</code></pre>"},{"location":"TRC-003/#risk-samples","title":"Risk Samples","text":"<ul> <li>01.sol </li> <li>02.sol </li> <li>03.sol </li> <li>04.sol</li> </ul>"},{"location":"TRC-004/","title":"TRC-004 BalanceManipulation","text":""},{"location":"TRC-004/#description","title":"Description","text":"<p>Tokens with this feature allow the owner to modify anyone's balance, potentially setting it to 0 or enabling massive minting and sell-off. This function generally relies on ownership. If the contract's owner cannot be retrieved, is a black hole address, or lacks an owner, ownership-related functionality is usually disabled.</p>"},{"location":"TRC-004/#risk-pattern","title":"Risk Pattern","text":"<pre><code>function setBalance(address user, uint256 value) public onlyOwner returns (bool) {\n  _balances[user] = value\n  return true;\n}\n</code></pre>"},{"location":"TRC-004/#risk-samples","title":"Risk Samples","text":"<ul> <li>01.sol </li> <li>02.sol </li> <li>03.sol </li> <li>04.sol</li> </ul>"},{"location":"TRC-005/","title":"TRC-005 HiddenOwnership","text":""},{"location":"TRC-005/#description","title":"Description","text":"<p>Hidden ownership is used by developers to maintain ownership ability even after abandoning ownership, and is often an indicator of malicious intent. When a hidden owner exists, the ownership has not been abandoned.</p>"},{"location":"TRC-005/#risk-pattern","title":"Risk Pattern","text":"<pre><code>modifier superman() {\n  require(superman == _msgSender(), );\n}\n</code></pre>"},{"location":"TRC-005/#risk-samples","title":"Risk Samples","text":"<ul> <li>01.sol </li> <li>02.sol </li> <li>03.sol </li> <li>04.sol</li> </ul>"},{"location":"TRC-006/","title":"TRC-006 SelfDestruction","text":""},{"location":"TRC-006/#description","title":"Description","text":"<p>When the self-destruct function is triggered, the contract is destroyed, making all its functions unavailable and erasing all related assets. This method can also be used to update the contract by replacing it with a new one.</p>"},{"location":"TRC-006/#risk-pattern","title":"Risk Pattern","text":"<pre><code>function close(address payable to) external onlyOwner { \n  selfdestruct(to); \n}\n</code></pre>"},{"location":"TRC-006/#risk-samples","title":"Risk Samples","text":"<ul> <li>01.sol </li> <li>02.sol </li> <li>03.sol </li> <li>04.sol</li> </ul>"},{"location":"TRC-007/","title":"TRC-007 ExternalInvocation","text":""},{"location":"TRC-007/#description","title":"Description","text":"<p>External calls make this contract's implementation dependent on other external contracts, which may introduce additional risks.</p>"},{"location":"TRC-007/#risk-pattern","title":"Risk Pattern","text":"<pre><code>function _transfer(address from, address recipient, uint256 amount) internal virtual override returns (bool) {\n  require(_balances[_msgSender()] &gt;= amount, );\n  _balances[_msgSender()] -= amount;\n  _balances[recipient] += amount;\n  address1.transfer(amount);\n  emit Transfer(_msgSender(), recipient, amount);\n  return true;\n}\n</code></pre>"},{"location":"TRC-007/#risk-samples","title":"Risk Samples","text":"<ul> <li>01.sol </li> <li>02.sol </li> <li>03.sol </li> <li>04.sol</li> </ul>"},{"location":"TRC-008/","title":"TRC-008 BlackListFunction","text":""},{"location":"TRC-008/#description","title":"Description","text":"<p>The contract owner can add any address to the blacklist, preventing those addresses from trading. Abuse of this function poses significant risks. For contracts without an owner, or if the owner is a black hole address, the blacklist cannot be updated, but the existing blacklist remains in effect.</p>"},{"location":"TRC-008/#risk-pattern","title":"Risk Pattern","text":"<pre><code>function _transfer(address from, address recipient, uint256 amount) internal virtual override returns (bool) {\n  require(_balances[_msgSender()] &gt;= amount, );\n  _balances[_msgSender()] -= amount;\n  _balances[recipient] += amount;\n  require(black[from] != 1,);\n  emit Transfer(_msgSender(), recipient, amount);\n  return true;\n}\n</code></pre>"},{"location":"TRC-008/#risk-samples","title":"Risk Samples","text":"<ul> <li>01.sol </li> <li>02.sol </li> <li>03.sol </li> <li>04.sol</li> </ul>"},{"location":"TRC-009/","title":"TRC-009 WhiteListFunction","text":""},{"location":"TRC-009/#description","title":"Description","text":"<p>WhiteListFunction is used to allow specific addresses to make early transactions, tax-free, and unaffected by transaction suspensions. For contracts without an owner, or if the owner is a black hole address, the whitelist cannot be updated, but the existing whitelist remains in effect.</p>"},{"location":"TRC-009/#risk-pattern","title":"Risk Pattern","text":"<pre><code>function _transfer(address from, address recipient, uint256 amount) internal virtual override returns (bool) {\n  require(_balances[_msgSender()] &gt;= amount, );\n  _balances[_msgSender()] -= amount;\n  uint256 fee = amount.mul(feeRate).div(100);\n  if (whitelist[msg.sender] == ture)\n  fee = 0;\n  _balances[recipient] += (amount-fee);\n  emit Transfer(_msgSender(), recipient, amount-fee);\n  return true;\n}\n</code></pre>"},{"location":"TRC-009/#risk-samples","title":"Risk Samples","text":"<ul> <li>01.sol </li> <li>02.sol </li> <li>03.sol </li> <li>04.sol</li> </ul>"},{"location":"TRC-010/","title":"TRC-010 SlippageModification","text":""},{"location":"TRC-010/#description","title":"Description","text":"<p>Tokens with modifiable tax allow the contract owner to change the buy or sell tax rates. This can cause losses, especially if the contract allows unlimited tax rate modifications, potentially making the token untradeable. This function generally relies on ownership. If the contract does not have an owner, or if the owner is a black hole address and cannot be retrieved, this function may be disabled.</p>"},{"location":"TRC-010/#risk-pattern","title":"Risk Pattern","text":"<pre><code>function _transfer(address from, address recipient, uint256 amount) internal virtual override returns (bool) {\n  require(_balances[_msgSender()] &gt;= amount, );\n  _balances[_msgSender()] -= amount;\n  uint256 fee = amount.mul(feeRate).div(100);\n  _balances[recipient] += (amount-fee);\n  emit Transfer(_msgSender(), recipient, amount-fee);\n  return true;\n}\n\nfunction setFee(uint256 _fee) external onlyOwner{\n  fee = _fee;\n}\n</code></pre>"},{"location":"TRC-010/#risk-samples","title":"Risk Samples","text":"<ul> <li>01.sol </li> <li>02.sol </li> <li>03.sol </li> <li>04.sol</li> </ul>"},{"location":"TRC-011/","title":"TRC-011 TransferPausable","text":""},{"location":"TRC-011/#description","title":"Description","text":"<p>TransferPausable allows the contract owner to suspend trading at any time, preventing anyone from selling except those with special authority. This function generally relies on ownership. If the contract does not have an owner, or if the owner is a black hole address and cannot be retrieved, this function maybe be disabled.</p>"},{"location":"TRC-011/#risk-pattern","title":"Risk Pattern","text":"<pre><code>function _transfer(address from, address recipient, uint256 amount) internal virtual override returns (bool) {\n  require(_balances[_msgSender()] &gt;= amount,);\n  require(tradeEnabled,);\n  _balances[_msgSender()] -= amount;\n  _balances[recipient] += amount;\n  emit Transfer(_msgSender(), recipient, amount);\n  return true;\n}\n\nfunction setTradeEnabled(bool _enabled) external onlyOwner {\n  tradeEnabled = _enabled;\n}\n</code></pre>"},{"location":"TRC-011/#risk-samples","title":"Risk Samples","text":"<ul> <li>01.sol </li> <li>02.sol </li> <li>03.sol </li> <li>04.sol</li> </ul>"},{"location":"TRC-012/","title":"TRC-012 PersonalSlippageModification","text":""},{"location":"TRC-012/#description","title":"Description","text":"<p>The contract owner can set an extremely high tax rate for a specific address to block it from trading. Abuse of this function poses significant risks. For contracts without an owner, or if the owner is a black hole address, this function cannot be used, but the existing tax rate remains in effect.</p>"},{"location":"TRC-012/#risk-pattern","title":"Risk Pattern","text":"<pre><code>function _transfer(address from, address recipient, uint256 amount) internal virtual override returns (bool) {\n  require(_balances[_msgSender()] &gt;= amount, \"TT: transfer amount exceeds balance\");\n  _balances[_msgSender()] -= amount;\n  if (addressFee[from] &gt; 0) {\n  fee = addressFee[from];\n  }\n  _balances[recipient] += (amount-fee);\n  emit Transfer(_msgSender(), recipient, amount-fee);\n  return true;\n}\n\nfunction setFee(address _address, uint256 _fee) external onlyOwner{\n  addressFee[from] = _fee;\n}\n</code></pre>"},{"location":"TRC-012/#risk-samples","title":"Risk Samples","text":"<ul> <li>01.sol </li> <li>02.sol </li> <li>03.sol </li> <li>04.sol</li> </ul>"},{"location":"TRC-013/","title":"TRC-013 SaleRestriction","text":""},{"location":"TRC-013/#description","title":"Description","text":"<p>SaleRestriction prevents users from selling all their tokens in a single sale. Users may be required to retain a certain percentage, such as 10%, or a fixed number of tokens, such as 10 tokens.</p>"},{"location":"TRC-013/#risk-pattern","title":"Risk Pattern","text":"<pre><code>function _transfer(address from, address recipient, uint256 amount) internal virtual override returns (bool) {\n  require(_balances[_msgSender()] &gt;= amount, );\n  require(_balances(from).sub(amount)&gt;=1*10**18,);\n  _balances[_msgSender()] -= amount;\n  _balances[recipient] += amount;\n  emit Transfer(_msgSender(), recipient, amount);\n  return true;\n}\n</code></pre>"},{"location":"TRC-013/#risk-samples","title":"Risk Samples","text":"<ul> <li>01.sol </li> <li>02.sol </li> <li>03.sol </li> <li>04.sol</li> </ul>"},{"location":"TRC-014/","title":"TRC-014 AntiWhale","text":""},{"location":"TRC-014/#description","title":"Description","text":"<p>AntiWhale describes whether the contract limits the maximum transaction amount or the maximum token holding for a single address. </p>"},{"location":"TRC-014/#risk-pattern","title":"Risk Pattern","text":"<pre><code>function _transfer(address from, address recipient, uint256 amount) internal virtual override returns (bool) {\n  require(_balances[_msgSender()] &gt;= amount, );\n  _balances[_msgSender()] -= amount;\n  require(amount &lt;= maxAmount,);\n  _balances[recipient] += (amount-fee);\n  emit Transfer(_msgSender(), recipient, amount-fee);\n  return true;\n}\n</code></pre>"},{"location":"TRC-014/#risk-samples","title":"Risk Samples","text":"<ul> <li>01.sol </li> <li>02.sol </li> <li>03.sol </li> <li>04.sol</li> </ul>"},{"location":"TRC-015/","title":"TRC-015 AntiWhaleModification","text":""},{"location":"TRC-015/#description","title":"Description","text":"<p>AntiWhaleModification describes whether the contract can modify the maximum transaction amount or the maximum token holding for a single address. For contracts without an owner, or if the owner is a black hole address, this risk may not happen.</p>"},{"location":"TRC-015/#risk-pattern","title":"Risk Pattern","text":"<pre><code>function _transfer(address from, address recipient, uint256 amount) internal virtual override returns (bool) {\n  require(_balances[_msgSender()] &gt;= amount, );\n  _balances[_msgSender()] -= amount;\n  require(amount &lt;= maxAmount,);\n  _balances[recipient] += (amount-fee);\n  emit Transfer(_msgSender(), recipient, amount-fee);\n  return true;\n}\n\nfunction setMaxAmount(uint256 _maxAmount) external onlyOwner {\n  maxAmount = _maxAmount;\n}\n</code></pre>"},{"location":"TRC-015/#risk-samples","title":"Risk Samples","text":"<ul> <li>01.sol </li> <li>02.sol </li> <li>03.sol </li> <li>04.sol</li> </ul>"},{"location":"TRC-016/","title":"TRC-016 TradingCooldown","text":""},{"location":"TRC-016/#description","title":"Description","text":"<p>TradingCooldown describes whether the contract has a trading cooldown mechanism that limits the minimum time between two transactions.</p>"},{"location":"TRC-016/#risk-pattern","title":"Risk Pattern","text":"<pre><code>function _transfer(address from, address recipient, uint256 amount) internal virtual override returns (bool) {\n  require(_balances[_msgSender()] &gt;= amount, );\n  _balances[_msgSender()] -= amount;\n  require(cooldownTimer[recipient] &lt; block.timestamp, );\n  cooldownTimer[recipient] = block.timestamp + cooldownTimerInterval;\n  _balances[recipient] += (amount-fee);\n  emit Transfer(_msgSender(), recipient, amount-fee);\n  return true;\n}\n</code></pre>"},{"location":"TRC-016/#risk-samples","title":"Risk Samples","text":"<ul> <li>01.sol </li> <li>02.sol </li> <li>03.sol </li> <li>04.sol</li> </ul>"},{"location":"contributing/","title":"Contribution Guidelines","text":"<p>This document describes the contribution guidelines for the Token Risk Classification project. We welcome any contributions including adding new risk types, adding new risk samples, and updating the documentation, etc.</p>"},{"location":"contributing/#risk-type-format","title":"Risk Type Format","text":"<p>All risk types are defined under src folder with the name of the risk type ID. For example, <code>TRC-001</code>. The folder should contain the following folders and files:</p> <p><code>metadata.json</code>: This file contains the metadata of the risk type. The metadata should be in the following format: <pre><code>{\n  \"id\": \"Risk Type ID\",\n  \"name\": \"Risk Type Name\",\n  \"description\": \"Risk Type Description\",\n  \"samples\": [\n    {\n      \"name\": \"01.sol\"\n    },\n    {\n      \"name\": \"02.sol\",\n      \"start\": 1,\n      \"end\": 10\n    },\n    {\n      \"name\": \"03.sol\"\n    }\n  ]\n}\n</code></pre> The fields in the metadata are:</p> <ul> <li><code>id</code>: The risk type ID.</li> <li><code>name</code>: The name of the risk type.</li> <li><code>description</code>: The description of the risk type.</li> <li><code>samples</code>: The list of sample contracts. Each sample contract should have a <code>name</code> field. If you want to specify the start line and end line of the risk code snippet in the contract, you can add <code>start</code> and <code>end</code> fields to the sample contract. The line numbers should be 1-indexed.</li> </ul> <p><code>samples</code> folder: This folder contains the sample contracts that demonstrate the risk type. The sample contracts should be named as <code>NN.sol</code>, e.g., <code>01.sol</code>, <code>02.sol</code>, <code>03.sol</code>, etc.</p> <p><code>pattern.sol</code>(optional): This file should contain the risk pattern, which is the code snippet that demonstrates the risk type. The code snippet should be in solidity.</p>"},{"location":"contributing/#contribute-new-risk-samples","title":"Contribute New Risk Samples","text":""},{"location":"contributing/#add-new-risk-samples-to-samples-folder","title":"Add New Risk Samples to samples Folder","text":"<p>If you want to add new risk samples to an existing risk type, you can add the new risk samples to the <code>samples</code> folder of the risk type folder under src. The sample contracts should be named as <code>NN.sol</code>, e.g., <code>01.sol</code>, <code>02.sol</code>, <code>03.sol</code>, etc.</p>"},{"location":"contributing/#update-metadatajson","title":"Update metadata.json","text":"<p>Update the <code>samples</code> field in the <code>metadata.json</code> file of the risk type folder under src.</p>"},{"location":"contributing/#contribute-new-risk-types","title":"Contribute New Risk Types","text":""},{"location":"contributing/#request-a-risk-type-id","title":"Request a Risk Type ID","text":"<p>Risk Type ID is defined in format <code>TRC-NNN</code> where <code>NNN</code> is the number of the risk type in that year. For example, <code>TRC-001</code>. Before adding a new risk type, please check if the risk type ID is already taken. If not, please request a new risk type ID by creating an issue in this repository. You can check the taken risk type IDs in under src folder.</p>"},{"location":"contributing/#create-a-new-risk-type-folder","title":"Create a new Risk Type Folder","text":"<p>Create a folder under src folder with the name of the risk type ID. Add folders and files based on the Risk Type Format section.</p>"},{"location":"contributing/#update-mkdocsyml","title":"Update mkdocs.yml","text":"<p>Add the new risk type to the <code>Risk Types</code> list under <code>nav</code> section in mkdocs.yml.</p>"},{"location":"contributing/#update-documentation","title":"Update Documentation","text":"<p>Everytime you add a new risk type or add new risk samples to an existing risk type, please update the documentation by executing the following command: <pre><code>make generate-docs\n</code></pre> This command will generate the documentation in docs folder. You can also preview the change by serving the documentation locally: <pre><code>mkdocs serve\n</code></pre> The documentation will be served at <code>http://localhost:8000/</code>.</p>"}]}